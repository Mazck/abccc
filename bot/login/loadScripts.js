const { readdirSync, readFileSync, writeFileSync, existsSync } = require("fs-extra");
const path = require("path");
const { Worker } = require("worker_threads");
const cluster = require("cluster");

// Promisify exec ƒë·ªÉ s·ª≠ d·ª•ng async/await
const exec = (cmd, options) => new Promise((resolve, reject) => {
	require("child_process").exec(cmd, options, (err, stdout) => {
		if (err) return reject(err);
		resolve(stdout);
	});
});

// Import global utilities
const { log, loading, getText, colors, removeHomeDir } = global.utils;
const { GoatBot } = global;
const { configCommands } = GoatBot;

// Constants v√† regex patterns
const regExpCheckPackage = /require(\s+|)\((\s+|)[`'"]([^`'"]+)[`'"](\s+|)\)/g;
const packageAlready = new Set();
const MAX_CONCURRENT_INSTALLS = 3;
const PACKAGE_INSTALL_TIMEOUT = 30000;

// Enhanced spinner animations
const spinners = {
	dots: ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'],
	pulse: ['‚£æ', '‚£Ω', '‚£ª', '‚¢ø', '‚°ø', '‚£ü', '‚£Ø', '‚£∑'],
	bounce: ['‚†Å', '‚†Ç', '‚†Ñ', '‚†Ç'],
	wave: ['‚ñÅ', '‚ñÉ', '‚ñÑ', '‚ñÖ', '‚ñÜ', '‚ñá', '‚ñà', '‚ñá', '‚ñÜ', '‚ñÖ', '‚ñÑ', '‚ñÉ']
};

// Loading state management
let animationFrame = 0;
let loadingStats = {
	total: 0,
	loaded: 0,
	errors: 0,
	startTime: Date.now(),
	currentFile: ''
};

/**
 * T·∫°o thanh progress bar v·ªõi gradient colors
 * @param {number} current - S·ªë l∆∞·ª£ng hi·ªán t·∫°i
 * @param {number} total - T·ªïng s·ªë l∆∞·ª£ng
 * @param {number} width - ƒê·ªô r·ªông thanh progress
 * @returns {string} Progress bar string
 */
const createProgressBar = (current, total, width = 35) => {
	const percentage = Math.min(Math.floor((current / total) * 100), 100);
	const filled = Math.floor((current / total) * width);
	const empty = width - filled;

	const progressChar = '‚ñà';
	const emptyChar = '‚ñë';

	const filledBar = colors.cyan(progressChar.repeat(filled));
	const emptyBar = colors.gray(emptyChar.repeat(empty));

	return `${filledBar}${emptyBar} ${colors.yellow(`${percentage}`.padStart(3))}% ${colors.white(`[${current}/${total}]`)}`;
};

/**
 * Hi·ªÉn th·ªã tr·∫°ng th√°i loading v·ªõi animation
 * @param {string} message - Th√¥ng ƒëi·ªáp hi·ªÉn th·ªã
 * @param {string} type - Lo·∫°i tr·∫°ng th√°i (info, success, error, warning)
 */
const displayLoadingProgress = (message, type = 'info') => {
	const spinner = spinners.pulse[animationFrame % spinners.pulse.length];
	const elapsed = ((Date.now() - loadingStats.startTime) / 1000).toFixed(1);

	const statusColors = {
		info: colors.cyan,
		success: colors.green,
		error: colors.red,
		warning: colors.yellow
	};

	const coloredSpinner = statusColors[type](spinner);
	const progressBar = createProgressBar(loadingStats.loaded, loadingStats.total);
	const timeDisplay = colors.gray(`${elapsed}s`);

	// Clear line v√† hi·ªÉn th·ªã progress
	process.stdout.write('\r\x1b[K');
	process.stdout.write(`${coloredSpinner} ${message} ‚îÇ ${progressBar} ‚îÇ ${timeDisplay}`);
	animationFrame++;
};

/**
 * C√†i ƒë·∫∑t packages song song v·ªõi gi·ªõi h·∫°n concurrent
 * @param {Array} packages - Danh s√°ch packages c·∫ßn c√†i
 */
const installPackagesParallel = async (packages) => {
	if (packages.length === 0) return;

	console.log(`\n${colors.yellow('üì¶')} Installing ${colors.white(packages.length)} missing packages...`);

	// Chia packages th√†nh chunks ƒë·ªÉ c√†i song song
	const chunks = [];
	for (let i = 0; i < packages.length; i += MAX_CONCURRENT_INSTALLS) {
		chunks.push(packages.slice(i, i + MAX_CONCURRENT_INSTALLS));
	}

	let installedCount = 0;
	let failedCount = 0;

	for (const chunk of chunks) {
		const promises = chunk.map(async (packageName) => {
			let animationInterval;

			try {
				// B·∫Øt ƒë·∫ßu animation cho package n√†y
				animationInterval = setInterval(() => {
					displayLoadingProgress(`Installing ${colors.yellow(packageName)}`, 'info');
				}, 100);

				await exec(`npm install ${packageName} --save --silent`, {
					timeout: PACKAGE_INSTALL_TIMEOUT
				});

				clearInterval(animationInterval);
				process.stdout.write('\r\x1b[K');

				console.log(`${colors.green('‚úì')} ${colors.white(packageName)} ${colors.gray('installed successfully')}`);
				installedCount++;

				return { packageName, success: true };
			} catch (error) {
				if (animationInterval) clearInterval(animationInterval);
				process.stdout.write('\r\x1b[K');

				console.log(`${colors.red('‚úó')} ${colors.white(packageName)} ${colors.red('installation failed')}`);
				failedCount++;

				return { packageName, success: false, error };
			}
		});

		await Promise.allSettled(promises);
	}

	// Summary c·ªßa vi·ªác c√†i ƒë·∫∑t packages
	console.log(`\n${colors.cyan('Package installation summary:')}`);
	console.log(`${colors.green('‚úì')} Installed: ${colors.white(installedCount)}`);
	if (failedCount > 0) {
		console.log(`${colors.red('‚úó')} Failed: ${colors.white(failedCount)}`);
	}
	console.log('');
};

/**
 * Ph√¢n t√≠ch v√† l·∫•y danh s√°ch packages t·ª´ file
 * @param {string} contentFile - N·ªôi dung file
 * @returns {Array} Danh s√°ch packages c·∫ßn c√†i
 */
const extractRequiredPackages = (contentFile) => {
	let allPackage = contentFile.match(regExpCheckPackage);
	const packagesToInstall = [];

	if (allPackage) {
		allPackage = allPackage
			.map(p => p.match(/[`'"]([^`'"]+)[`'"]/)[1])
			.filter(p => !p.startsWith('/') && !p.startsWith('./') && !p.startsWith('../') && !p.includes(__dirname));

		for (let packageName of allPackage) {
			// X·ª≠ l√Ω scoped packages (@scope/package)  
			if (packageName.startsWith('@')) {
				packageName = packageName.split('/').slice(0, 2).join('/');
			} else {
				packageName = packageName.split('/')[0];
			}

			if (!packageAlready.has(packageName)) {
				packageAlready.add(packageName);
				if (!existsSync(`${process.cwd()}/node_modules/${packageName}`)) {
					packagesToInstall.push(packageName);
				}
			}
		}
	}

	return packagesToInstall;
};

/**
 * Validate c·∫•u h√¨nh command
 * @param {Object} command - Command object
 * @param {string} text - Lo·∫°i command (command/event command)
 * @param {string} commandName - T√™n command
 */
const validateCommand = (command, text, commandName) => {
	const configCommand = command.config;

	if (!configCommand) throw new Error(`Missing config in ${text}`);
	if (!configCommand.category) throw new Error(`Missing category in ${text}`);
	if (!commandName) throw new Error(`Missing name in ${text}`);
	if (!command.onStart) throw new Error(`Missing onStart in ${text}`);
	if (typeof command.onStart !== "function") throw new Error(`onStart must be a function in ${text}`);

	if (GoatBot.commands.has(commandName) || GoatBot.eventCommands.has(commandName)) {
		const existingLocation = GoatBot.commands.get(commandName)?.location || GoatBot.eventCommands.get(commandName)?.location;
		throw new Error(`${text} "${commandName}" already exists in "${removeHomeDir(existingLocation || "")}"`);
	}
};

/**
 * X·ª≠ l√Ω aliases c·ªßa command
 * @param {Object} configCommand - Config c·ªßa command
 * @param {string} commandName - T√™n command
 * @param {string} text - Lo·∫°i command
 * @returns {Array} Danh s√°ch aliases h·ª£p l·ªá
 */
const processAliases = (configCommand, commandName, text) => {
	const validAliases = [];

	if (configCommand.aliases) {
		if (!Array.isArray(configCommand.aliases)) {
			throw new Error("config.aliases must be an array");
		}

		// Check duplicate aliases trong c√πng command
		const aliasSet = new Set();
		for (const alias of configCommand.aliases) {
			if (aliasSet.has(alias)) {
				throw new Error(`Duplicate alias "${alias}" in ${text} "${commandName}"`);
			}
			aliasSet.add(alias);

			if (GoatBot.aliases.has(alias)) {
				throw new Error(`Alias "${alias}" already exists in command "${GoatBot.aliases.get(alias)}"`);
			}
			validAliases.push(alias);
		}

		// ƒêƒÉng k√Ω aliases
		for (const alias of validAliases) {
			GoatBot.aliases.set(alias, commandName);
		}
	}

	return validAliases;
};

/**
 * X·ª≠ l√Ω environment configs
 * @param {Object} configCommand - Config c·ªßa command
 * @param {string} pathCommand - ƒê∆∞·ªùng d·∫´n file command
 * @param {string} commandName - T√™n command
 * @param {string} typeEnvCommand - Lo·∫°i env command
 */
const processEnvironmentConfig = (configCommand, pathCommand, commandName, typeEnvCommand) => {
	const { envGlobal, envConfig } = configCommand;

	// X·ª≠ l√Ω envGlobal
	if (envGlobal) {
		if (typeof envGlobal !== "object" || Array.isArray(envGlobal)) {
			throw new Error("envGlobal must be an object");
		}

		for (const [key, value] of Object.entries(envGlobal)) {
			if (!configCommands.envGlobal[key]) {
				configCommands.envGlobal[key] = value;
			} else {
				// Update file v·ªõi gi√° tr·ªã t·ª´ config
				const fileContent = readFileSync(pathCommand, "utf-8");
				const updatedContent = fileContent.replace(value, configCommands.envGlobal[key]);
				writeFileSync(pathCommand, updatedContent);
			}
		}
	}

	// X·ª≠ l√Ω envConfig
	if (envConfig) {
		if (typeof envConfig !== "object" || Array.isArray(envConfig)) {
			throw new Error("envConfig must be an object");
		}

		if (!configCommands[typeEnvCommand]) configCommands[typeEnvCommand] = {};
		if (!configCommands[typeEnvCommand][commandName]) configCommands[typeEnvCommand][commandName] = {};

		for (const [key, value] of Object.entries(envConfig)) {
			if (!configCommands[typeEnvCommand][commandName][key]) {
				configCommands[typeEnvCommand][commandName][key] = value;
			} else {
				// Update file v·ªõi gi√° tr·ªã t·ª´ config
				const fileContent = readFileSync(pathCommand, "utf-8");
				const updatedContent = fileContent.replace(value, configCommands[typeEnvCommand][commandName][key]);
				writeFileSync(pathCommand, updatedContent);
			}
		}
	}
};

/**
 * Load v√† x·ª≠ l√Ω m·ªôt script file
 * @param {string} pathCommand - ƒê∆∞·ªùng d·∫´n file
 * @param {string} file - T√™n file
 * @param {string} text - Lo·∫°i command
 * @param {string} setMap - Map ƒë·ªÉ set command
 * @param {string} typeEnvCommand - Lo·∫°i env command
 * @param {string} folderModules - Th∆∞ m·ª•c ch·ª©a module
 */
const loadScriptFile = async (pathCommand, file, text, setMap, typeEnvCommand, folderModules) => {
	try {
		loadingStats.currentFile = file;

		// ƒê·ªçc n·ªôi dung file v√† ph√¢n t√≠ch packages
		const contentFile = readFileSync(pathCommand, "utf8");
		const packagesToInstall = extractRequiredPackages(contentFile);

		// C√†i ƒë·∫∑t packages thi·∫øu
		if (packagesToInstall.length > 0) {
			await installPackagesParallel(packagesToInstall);
		}

		// Load command v√† validate
		delete require.cache[require.resolve(pathCommand)];
		global.temp.contentScripts = global.temp.contentScripts || {};
		global.temp.contentScripts[folderModules] = global.temp.contentScripts[folderModules] || {};
		global.temp.contentScripts[folderModules][file] = contentFile;

		const command = require(pathCommand);
		command.location = pathCommand;

		const configCommand = command.config;
		const commandName = configCommand?.name;

		// Validate command
		validateCommand(command, text, commandName);

		// X·ª≠ l√Ω aliases
		const validAliases = processAliases(configCommand, commandName, text);

		// X·ª≠ l√Ω environment configs
		processEnvironmentConfig(configCommand, pathCommand, commandName, typeEnvCommand);

		// Execute onLoad function n·∫øu c√≥
		if (configCommand.onLoad && typeof configCommand.onLoad === "function") {
			await configCommand.onLoad({
				api, threadModel, userModel, dashBoardModel, globalModel,
				threadsData, usersData, dashBoardData, globalData
			});
		}

		// ƒêƒÉng k√Ω event handlers
		const { onChat, onFirstChat, onEvent, onAnyEvent } = configCommand;
		if (onChat) GoatBot.onChat.push(commandName);
		if (onFirstChat) GoatBot.onFirstChat.push({ commandName, threadIDsChattedFirstTime: [] });
		if (onEvent) GoatBot.onEvent.push(commandName);
		if (onAnyEvent) GoatBot.onAnyEvent.push(commandName);

		// ƒêƒÉng k√Ω command v√†o GoatBot
		GoatBot[setMap].set(commandName.toLowerCase(), command);

		// L∆∞u th√¥ng tin file path
		const filePathInfo = {
			filePath: path.normalize(pathCommand),
			commandName: [commandName, ...validAliases]
		};

		const pathArrayKey = folderModules === "cmds" ? "commandFilesPath" : "eventCommandsFilesPath";
		global.GoatBot[pathArrayKey] = global.GoatBot[pathArrayKey] || [];
		global.GoatBot[pathArrayKey].push(filePathInfo);

		return {
			success: true,
			name: file,
			commandName,
			aliases: validAliases,
			category: configCommand.category
		};

	} catch (error) {
		return {
			success: false,
			name: file,
			error: {
				message: error.message,
				stack: error.stack
			}
		};
	}
};

/**
 * Hi·ªÉn th·ªã header v·ªõi style ƒë·∫πp
 */
const displayHeader = () => {
	const headerLines = [
		'‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê',
		'‚îÇ                  üöÄ GOAT SCRIPT LOADER üöÄ               ‚îÇ',
		'‚îÇ                    Loading Commands...                  ‚îÇ',
		'‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò'
	];

	console.log('');
	headerLines.forEach(line => console.log(colors.cyan(line)));
	console.log('');
};

/**
 * Hi·ªÉn th·ªã summary k·∫øt qu·∫£ load
 * @param {string} folderType - Lo·∫°i folder (commands/events)
 * @param {number} successCount - S·ªë l∆∞·ª£ng th√†nh c√¥ng
 * @param {number} errorCount - S·ªë l∆∞·ª£ng l·ªói
 * @param {number} elapsed - Th·ªùi gian th·ª±c hi·ªán
 */
const displaySummary = (folderType, successCount, errorCount, elapsed) => {
	console.log(colors.cyan('='.repeat(60)));
	console.log(`${colors.green('‚úì Successfully loaded:')} ${colors.white(successCount)} files`);
	if (errorCount > 0) {
		console.log(`${colors.red('‚úó Failed to load:')} ${colors.white(errorCount)} files`);
	}
	console.log(`${colors.blue('Total time:')} ${colors.white(elapsed)}s`);
	console.log(`${colors.yellow('Success rate:')} ${colors.white(Math.round((successCount / (successCount + errorCount)) * 100))}%`);
	console.log(colors.cyan('‚ïê'.repeat(60)));
};

/**
 * Hi·ªÉn th·ªã chi ti·∫øt l·ªói
 * @param {Array} errors - Danh s√°ch l·ªói
 * @param {string} type - Lo·∫°i command
 */
const displayErrors = (errors, type) => {
	if (errors.length === 0) return;

	console.log(`\n${colors.red('üö® LOADING ERRORS:')}`);
	console.log(colors.red('‚îÄ'.repeat(50)));

	errors.forEach((item, index) => {
		console.log(`\n${colors.red(`${index + 1}.`)} ${colors.yellow(item.name)}`);
		console.log(`   ${colors.red('‚îî‚îÄ')} ${colors.white(item.error.message)}`);

		if (process.env.NODE_ENV === 'development' && item.error.stack) {
			const stackLines = item.error.stack.split('\n').slice(1, 4);
			stackLines.forEach(line => {
				console.log(`      ${colors.gray(line.trim())}`);
			});
		}
	});
	console.log('');
};

/**
 * Main function - Load t·∫•t c·∫£ scripts
 */
module.exports = async function (api, threadModel, userModel, dashBoardModel, globalModel, threadsData, usersData, dashBoardData, globalData) {
	displayHeader();

	// X·ª≠ l√Ω aliases t·ª´ database
	try {
		const aliasesData = await globalData.get('setalias', 'data', []);
		if (aliasesData && Array.isArray(aliasesData)) {
			for (const data of aliasesData) {
				const { aliases, commandName } = data;
				if (aliases && Array.isArray(aliases)) {
					for (const alias of aliases) {
						if (GoatBot.aliases.has(alias)) {
							console.log(`${colors.yellow('‚ö†Ô∏è')} Alias "${alias}" already exists, skipping...`);
							continue;
						}
						GoatBot.aliases.set(alias, commandName);
					}
				}
			}
		}
	} catch (error) {
		console.log(`${colors.red('‚ö†Ô∏è')} Error loading aliases: ${error.message}`);
	}

	const folders = ["cmds", "events"];
	let totalSuccess = 0;
	let totalErrors = 0;

	for (const folderModules of folders) {
		const folderConfig = {
			cmds: {
				text: "command",
				typeEnvCommand: "envCommands",
				setMap: "commands",
				displayName: "Commands"
			},
			events: {
				text: "event command",
				typeEnvCommand: "envEvents",
				setMap: "eventCommands",
				displayName: "Events"
			}
		};

		const { text, typeEnvCommand, setMap, displayName } = folderConfig[folderModules];
		const fullPathModules = path.normalize(`${process.cwd()}/scripts/${folderModules}`);

		// Filter files c·∫ßn load
		const allFiles = readdirSync(fullPathModules);
		const validFiles = allFiles.filter(file => {
			const isJsFile = file.endsWith(".js");
			const isNotExample = !file.endsWith("eg.js");
			const isNotDev = process.env.NODE_ENV === "development" || !file.match(/(dev)\.js$/g);
			const isNotUnloaded = !configCommands[folderModules === "cmds" ? "commandUnload" : "commandEventUnload"]?.includes(file);

			return isJsFile && isNotExample && isNotDev && isNotUnloaded;
		});

		if (validFiles.length === 0) {
			console.log(`${colors.yellow('‚ö†Ô∏è')} No ${text}s found in ${folderModules} folder\n`);
			continue;
		}

		// Reset loading stats
		loadingStats = {
			total: validFiles.length,
			loaded: 0,
			errors: 0,
			startTime: Date.now(),
			currentFile: ''
		};

		console.log(`${colors.blue('üìÅ')} Loading ${colors.white(displayName)} from ${colors.cyan(folderModules)} folder`);
		console.log(`${colors.gray('Found')} ${colors.white(validFiles.length)} ${colors.gray('files to process')}\n`);

		const commandErrors = [];
		let commandLoadSuccess = 0;

		// Start loading animation
		const loadingInterval = setInterval(() => {
			if (loadingStats.currentFile) {
				displayLoadingProgress(`Loading ${colors.white(loadingStats.currentFile)}`, 'info');
			}
		}, 100);

		// Load files v·ªõi Promise.allSettled ƒë·ªÉ x·ª≠ l√Ω t·ªët h∆°n
		const results = await Promise.allSettled(
			validFiles.map(async (file) => {
				const pathCommand = path.normalize(`${fullPathModules}/${file}`);
				return await loadScriptFile(pathCommand, file, text, setMap, typeEnvCommand, folderModules);
			})
		);

		// Clear loading animation
		clearInterval(loadingInterval);
		process.stdout.write('\r\x1b[K');

		// Process results
		for (const result of results) {
			loadingStats.loaded++;

			if (result.status === 'fulfilled') {
				const { success, name, error, commandName, aliases, category } = result.value;

				if (success) {
					commandLoadSuccess++;
					const aliasText = aliases && aliases.length > 0 ? ` ${colors.gray(`[${aliases.join(', ')}]`)}` : '';
					console.log(`${colors.green('‚úì')} ${colors.white(name)} ${colors.gray('‚Üí')} ${colors.cyan(commandName)}${aliasText} ${colors.gray(`(${category})`)}`);
				} else {
					commandErrors.push({ name, error });
					console.log(`${colors.red('‚úó')} ${colors.white(name)} ${colors.red('failed to load')}`);
				}
			} else {
				commandErrors.push({ name: 'unknown', error: { message: result.reason?.message || 'Unknown error', stack: result.reason?.stack } });
				console.log(`${colors.red('‚úó')} ${colors.white('unknown')} ${colors.red('failed to load')}`);
			}
		}

		// Calculate statistics
		const elapsed = ((Date.now() - loadingStats.startTime) / 1000).toFixed(2);
		totalSuccess += commandLoadSuccess;
		totalErrors += commandErrors.length;

		// Display summary for this folder
		displaySummary(displayName, commandLoadSuccess, commandErrors.length, elapsed);

		// Display errors if any
		if (commandErrors.length > 0) {
			displayErrors(commandErrors, text);
		}
	}

	// Final summary
	console.log(`\n${colors.green('  SCRIPT LOADING COMPLETED!')}`);
	console.log(`${colors.white('Total loaded:')} ${colors.green(totalSuccess)} ${colors.gray('|')} ${colors.white('Total errors:')} ${colors.red(totalErrors)}`);
	console.log(`${colors.white('Overall success rate:')} ${colors.cyan(Math.round((totalSuccess / (totalSuccess + totalErrors)) * 100))}%\n`);
};